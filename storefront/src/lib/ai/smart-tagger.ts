/**
 * Smart Tagger System
 * Automatically generates and maintains product tags for optimal AI filtering
 * Based on GPT5 recommendations for improved search and discovery
 */

import { createClient } from '@/lib/supabase/server';

export interface TagConfig {
  colorSynonyms: Record<string, string[]>;
  categoryOccasions: Record<string, string[]>;
  seasonalDates: Record<string, [number, number]>;
  weightings: Record<string, number>;
  materialKeywords: string[];
}

export interface ProductTag {
  productId: string;
  tag: string;
  tagType: 'color' | 'category' | 'occasion' | 'material' | 'booster' | 'style';
  weight: number;
  autoGenerated: boolean;
  lastUpdated: Date;
}

export class SmartTagger {
  private config: TagConfig = {
    // Color synonyms mapping for search expansion
    colorSynonyms: {
      'blue': ['navy', 'royal-blue', 'midnight-blue', 'sky-blue', 'cobalt', 'indigo'],
      'grey': ['gray', 'charcoal', 'silver', 'slate', 'ash', 'smoke'],
      'brown': ['chocolate', 'tan', 'beige', 'khaki', 'camel', 'mocha', 'coffee'],
      'red': ['burgundy', 'maroon', 'crimson', 'scarlet', 'wine', 'cherry'],
      'green': ['emerald', 'forest', 'olive', 'sage', 'mint', 'hunter'],
      'purple': ['violet', 'plum', 'lavender', 'lilac', 'mauve'],
      'pink': ['rose', 'blush', 'coral', 'salmon', 'fuchsia', 'magenta'],
      'white': ['ivory', 'cream', 'pearl', 'snow', 'off-white'],
      'black': ['onyx', 'jet', 'ebony', 'midnight'],
      'gold': ['champagne', 'brass', 'honey', 'amber'],
      'orange': ['rust', 'burnt-orange', 'tangerine', 'peach', 'apricot']
    },
    
    // Category to occasion mapping
    categoryOccasions: {
      'suit': ['wedding', 'business', 'formal', 'professional', 'interview'],
      'tuxedo': ['black-tie', 'gala', 'wedding', 'prom', 'formal'],
      'blazer': ['cocktail', 'date-night', 'smart-casual', 'business-casual'],
      'dress-shirt': ['business', 'formal', 'professional', 'wedding'],
      'tie': ['business', 'formal', 'wedding', 'professional'],
      'vest': ['wedding', 'formal', 'prom', 'vintage'],
      'suspenders': ['wedding', 'vintage', 'formal', 'hipster'],
      'bow-tie': ['black-tie', 'formal', 'wedding', 'prom']
    },
    
    // Seasonal date ranges (month-based)
    seasonalDates: {
      'spring': [3, 5],  // March-May
      'summer': [6, 8],  // June-August
      'fall': [9, 11],   // September-November
      'winter': [12, 2]  // December-February
    },
    
    // AI scoring weights
    weightings: {
      'color': 20,
      'occasion': 15,
      'booster': 10,
      'category': 5,
      'style': 5,
      'material': 3
    },
    
    // Material keywords to extract
    materialKeywords: [
      'wool', 'cotton', 'silk', 'linen', 'polyester', 'velvet', 
      'cashmere', 'tweed', 'satin', 'leather', 'suede', 'denim',
      'microfiber', 'stretch', 'blend', 'italian-wool', 'egyptian-cotton'
    ]
  };

  /**
   * Main tagging function - processes a product and generates all tags
   */
  async generateTags(product: any): Promise<ProductTag[]> {
    const tags: ProductTag[] = [];
    const productText = `${product.name} ${product.description} ${product.category}`.toLowerCase();
    
    // 1. Extract and process color tags
    const colorTags = this.extractColorTags(productText, product);
    tags.push(...colorTags);
    
    // 2. Extract category tags
    const categoryTags = this.extractCategoryTags(product);
    tags.push(...categoryTags);
    
    // 3. Generate occasion tags based on category
    const occasionTags = this.generateOccasionTags(product);
    tags.push(...occasionTags);
    
    // 4. Extract material tags
    const materialTags = this.extractMaterialTags(productText);
    tags.push(...materialTags);
    
    // 5. Add style tags
    const styleTags = this.extractStyleTags(productText);
    tags.push(...styleTags);
    
    // 6. Add dynamic booster tags
    const boosterTags = await this.generateBoosterTags(product);
    tags.push(...boosterTags);
    
    return tags;
  }

  /**
   * Extract color tags with synonym mapping
   */
  private extractColorTags(text: string, product: any): ProductTag[] {
    const tags: ProductTag[] = [];
    const foundColors = new Set<string>();
    
    // Check for direct color mentions
    for (const [baseColor, synonyms] of Object.entries(this.config.colorSynonyms)) {
      // Check base color
      if (text.includes(baseColor)) {
        foundColors.add(baseColor);
      }
      
      // Check synonyms
      for (const synonym of synonyms) {
        if (text.includes(synonym)) {
          foundColors.add(baseColor); // Map to base color
          foundColors.add(synonym);   // Also keep specific color
        }
      }
    }
    
    // Extract from bundle components if present
    if (product.bundleComponents) {
      if (product.bundleComponents.suit?.color) {
        const suitColor = product.bundleComponents.suit.color.toLowerCase();
        foundColors.add(this.mapToBaseColor(suitColor));
      }
      if (product.bundleComponents.shirt?.color) {
        const shirtColor = product.bundleComponents.shirt.color.toLowerCase();
        foundColors.add(this.mapToBaseColor(shirtColor));
      }
      if (product.bundleComponents.tie?.color) {
        const tieColor = product.bundleComponents.tie.color.toLowerCase();
        foundColors.add(this.mapToBaseColor(tieColor));
      }
    }
    
    // Convert to tags
    foundColors.forEach(color => {
      tags.push({
        productId: product.id,
        tag: color,
        tagType: 'color',
        weight: this.config.weightings.color,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    });
    
    return tags;
  }

  /**
   * Map specific color to base color for synonym expansion
   */
  private mapToBaseColor(color: string): string {
    for (const [baseColor, synonyms] of Object.entries(this.config.colorSynonyms)) {
      if (synonyms.includes(color)) {
        return baseColor;
      }
    }
    return color;
  }

  /**
   * Extract category tags from product
   */
  private extractCategoryTags(product: any): ProductTag[] {
    const tags: ProductTag[] = [];
    const categories = new Set<string>();
    
    // Primary category
    if (product.category) {
      categories.add(product.category.toLowerCase());
    }
    
    // Product type
    if (product.product_type) {
      categories.add(product.product_type.toLowerCase());
    }
    
    // Extract from name
    const categoryKeywords = Object.keys(this.config.categoryOccasions);
    const productName = product.name.toLowerCase();
    
    categoryKeywords.forEach(keyword => {
      if (productName.includes(keyword)) {
        categories.add(keyword);
      }
    });
    
    // Special handling for multi-piece suits
    if (productName.includes('three-piece') || productName.includes('3-piece')) {
      categories.add('three-piece');
    }
    if (productName.includes('two-piece') || productName.includes('2-piece')) {
      categories.add('two-piece');
    }
    
    // Convert to tags
    categories.forEach(category => {
      tags.push({
        productId: product.id,
        tag: category,
        tagType: 'category',
        weight: this.config.weightings.category,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    });
    
    return tags;
  }

  /**
   * Generate occasion tags based on category
   */
  private generateOccasionTags(product: any): ProductTag[] {
    const tags: ProductTag[] = [];
    const occasions = new Set<string>();
    
    // Get occasions from category mapping
    const productCategories = this.extractCategoryTags(product)
      .map(tag => tag.tag);
    
    productCategories.forEach(category => {
      const mappedOccasions = this.config.categoryOccasions[category];
      if (mappedOccasions) {
        mappedOccasions.forEach(occasion => occasions.add(occasion));
      }
    });
    
    // Add from explicit occasions field
    if (product.occasions) {
      product.occasions.forEach((occasion: string) => 
        occasions.add(occasion.toLowerCase())
      );
    }
    
    // Convert to tags
    occasions.forEach(occasion => {
      tags.push({
        productId: product.id,
        tag: occasion,
        tagType: 'occasion',
        weight: this.config.weightings.occasion,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    });
    
    return tags;
  }

  /**
   * Extract material tags from product text
   */
  private extractMaterialTags(text: string): ProductTag[] {
    const tags: ProductTag[] = [];
    const foundMaterials = new Set<string>();
    
    this.config.materialKeywords.forEach(material => {
      if (text.includes(material)) {
        foundMaterials.add(material);
      }
    });
    
    // Convert to tags
    foundMaterials.forEach(material => {
      tags.push({
        productId: '',
        tag: material,
        tagType: 'material',
        weight: this.config.weightings.material,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    });
    
    return tags;
  }

  /**
   * Extract style tags from product text
   */
  private extractStyleTags(text: string): ProductTag[] {
    const tags: ProductTag[] = [];
    const styleKeywords = [
      'classic', 'modern', 'contemporary', 'traditional', 'vintage',
      'slim-fit', 'classic-fit', 'modern-fit', 'athletic-fit', 'relaxed-fit',
      'trendy', 'timeless', 'elegant', 'sophisticated', 'casual', 'formal'
    ];
    
    const foundStyles = new Set<string>();
    
    styleKeywords.forEach(style => {
      if (text.includes(style)) {
        foundStyles.add(style);
      }
    });
    
    // Convert to tags
    foundStyles.forEach(style => {
      tags.push({
        productId: '',
        tag: style,
        tagType: 'style',
        weight: this.config.weightings.style,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    });
    
    return tags;
  }

  /**
   * Generate dynamic booster tags based on analytics and date
   */
  private async generateBoosterTags(product: any): Promise<ProductTag[]> {
    const tags: ProductTag[] = [];
    
    // 1. Seasonal tag based on current date
    const currentMonth = new Date().getMonth() + 1;
    const season = this.getCurrentSeason(currentMonth);
    tags.push({
      productId: product.id,
      tag: season,
      tagType: 'booster',
      weight: this.config.weightings.booster,
      autoGenerated: true,
      lastUpdated: new Date()
    });
    
    // 2. Trending tag based on analytics (would need real analytics data)
    const isTrending = await this.checkIfTrending(product.id);
    if (isTrending) {
      tags.push({
        productId: product.id,
        tag: 'trending',
        tagType: 'booster',
        weight: this.config.weightings.booster,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    }
    
    // 3. Best seller tag based on sales data
    const isBestSeller = await this.checkIfBestSeller(product.id);
    if (isBestSeller) {
      tags.push({
        productId: product.id,
        tag: 'best-seller',
        tagType: 'booster',
        weight: this.config.weightings.booster,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    }
    
    // 4. Bundle tag for actual bundles
    if (product.isBundle || product.bundleComponents) {
      tags.push({
        productId: product.id,
        tag: 'bundle',
        tagType: 'booster',
        weight: this.config.weightings.booster,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    }
    
    // 5. New arrival tag (if created in last 30 days)
    const createdDate = new Date(product.created_at);
    const daysSinceCreation = (Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24);
    if (daysSinceCreation <= 30) {
      tags.push({
        productId: product.id,
        tag: 'new-arrival',
        tagType: 'booster',
        weight: this.config.weightings.booster,
        autoGenerated: true,
        lastUpdated: new Date()
      });
    }
    
    return tags;
  }

  /**
   * Get current season based on month
   */
  private getCurrentSeason(month: number): string {
    for (const [season, [start, end]] of Object.entries(this.config.seasonalDates)) {
      if (end < start) {
        // Handle winter (Dec-Feb)
        if (month >= start || month <= end) {
          return season;
        }
      } else {
        if (month >= start && month <= end) {
          return season;
        }
      }
    }
    return 'all-season';
  }

  /**
   * Check if product is trending (mock - would use real analytics)
   */
  private async checkIfTrending(productId: string): Promise<boolean> {
    // In production, this would query analytics data
    // For now, return mock data
    const supabase = await createClient();
    
    // Check if product has high view count in last 30 days
    // This is a placeholder - implement with real analytics
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    // Mock: randomly mark 20% as trending
    return Math.random() < 0.2;
  }

  /**
   * Check if product is a best seller (mock - would use real sales data)
   */
  private async checkIfBestSeller(productId: string): Promise<boolean> {
    // In production, this would query sales data
    // For now, return mock data
    
    // Mock: randomly mark 15% as best sellers
    return Math.random() < 0.15;
  }

  /**
   * Batch update tags for all products
   */
  async updateAllProductTags(): Promise<void> {
    const supabase = await createClient();
    
    // Fetch all products
    const { data: products, error } = await supabase
      .from('products')
      .select('*')
      .eq('status', 'active');
    
    if (error || !products) {
      console.error('Error fetching products:', error);
      return;
    }
    
    // Process each product
    for (const product of products) {
      // Generate tags for the product
      const tags = await this.generateTags(product);
      
      // Convert tags to simple array for storage
      const tagArray = tags.map(t => t.tag);
      
      // Update product with new tags
      const { error: updateError } = await supabase
        .from('products')
        .update({ 
          tags: tagArray,
          tags_updated_at: new Date().toISOString()
        })
        .eq('id', product.id);
      
      if (updateError) {
        console.error(`Error updating tags for product ${product.id}:`, updateError);
      }
    }
  }
}

// Export singleton instance
export const smartTagger = new SmartTagger();